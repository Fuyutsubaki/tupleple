１：std::tuple限定にすればよいのではないか
	どうせアウトプットはstd::tupleだし、std::tupleに統一すればデバックが楽になるのでは？
２：sequence滅びるべし
	Indexに移行中。自前のmapやfilterが使えないのは痛い
３：フォルダ分けしたい
４：foldr(bi_fun) | filter(Pred()) | map(trans)みたいにしたい
５：４が可能であるとfilterは要素の参照のタプル返してもいいのではなかろうか
６：sequence滅ぼしといてなんだけれど間に変換するヤツ作ればよかったのでは。
７：sub_tupleってどうよ。filterとかtakeとか要素に変更を及ぼさない系の関数に
８：方針としてstd::tupleのみに対応、O(N)を減らす
９：わかったことがある。index_tuple_idiomはmapで扱うと便利
１０：alias templateだと可変長テンプレートでおかしくなる場合がある。ひとまずzipとcatの可変長版はflexに退避
１１：foldとzipとcatに変更がありました。foldはfold1を追加しました。zip catは2変数にのみ対応となります(可変長はflexを使って)
１２：flexはたまたま近くにいた触手の名前だ。深い意味はない
１３：そんなことよりずっと目をそらし続けてきたconst T&,T&x,T&&xの使い分けの方が深刻な問題だ
１４：遅延評価したい。しかしそれにはstd::tuple以外も使えるようにしなければならない
１５：lazy::takeとか作りたいけどどーしよ
	１：std::tuple<int>をstd::tuple<int()>として遅延評価とする
		問題点	いちいち手動で評価するのがめんどい
			しかしstd::getとかを特殊化したくはない
	２：lazy_tupleを作って返してどうにかする
			std::tupleを原則的に使うという法則が崩れる
１６：2にした。そしてeval的なものを付けてstd::tupleに変換、もとい評価できるようにする
１７：tuple_definerなるものが必要だ
１８：lazy_tupleが本当にlazyという名前でいいのかわからない